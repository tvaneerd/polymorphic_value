[section Tutorial]

[section Motivation]

Object-oriented programming allows objects to be composed of other objects.  A
class heirarchy of `Shape`s might lead to a `Picture` class being a collection
of `Shape`s and their respective positions.

When components are stored as values, the compiler is able to generate special
member functions: destructor, copy constructor, copy assignment operator, move
constructor and move assignment operator.

Storing components as values means that the type of the component must be known
at compile time. For cases when components are base classes from an inheritance
heirarchy - like `Shape`s in a `Picture` - we are unable to store components as
values and will have to implement special member functions ourselves.

`polymorphic_value` is a class template that imparts value semantics to a
polymorphic object. Use of it allows design of a composite object in terms of
abstract or base class objects without the need to implement (and maintain)
special member functions.

    class Shape;
    class Picture {
      std::vector<boost::polymorphic_value<Shape>> components_;
      // ...
    };

[endsect]

[section Design Overview]

A `polymorphic_value` member can be used with the same syntax one would use for
a pointer member: `operator->` and `operator*` will respectively return a
pointer and a reference. Like a pointer, `polymorphic_value` can be null so
should probably be initialised within the parent object constructor. 

`polymorphic_value` has value semantics: when copied, it will perform a deep
copy of the owned object, and it propagates `const` to the owned object.

[heading Deep copies]

`polymorphic_value` enables deep-copies through inheritance heirarchies: a
`polymorphic_value<Shape>` initialized with a `Circle` object will produce a
`polymorphic_value<Shape>` managing a copy of the `Circle` object produced
using `Circle`'s copy constructor.

Virtual destructors can be used to ensure that a derived class object is
correctly destroyed through a base class pointer. C++ offers no equivalent of
virtual destructors for copy construction; `polymorphic_value` uses
type-erasure to store type information about the managed object and call the
copy constructor when required. Note that virtual destructors are not needed
for `polymorphic_value` as the type-erasure mechanism used to produce copies is
  also used to call the correct derived class destructor.

[heading Const-propagation]

As `polymorphic_value` is intended to be used to model a value-type, a
`const` `polymorphic_value<T>` will only give access to a `const T&` and `const
T*`.  For non-`const` access, a non-`const` `polymorphic_value<T>` is needed.

For design of component-based objects, const-propagation is required as no part
of a contextually immutable object should be mutable. Where access to a mutable
`polymorphic_value<T>` is truly required from a `const` access path, a `mutable
polymorphic_value<T>` member can be used (this should be rare).

[heading Default construction and a null state]

`polymorphic_value` is intended to be used with Standard Library collections
which requires that it is default constructible. As `polymorphic_value<T>` can
be instantiated for an abstract class `T`, the default constructor cannot, in
general, default construct the managed object. There may also be cases where
default construction of the managed object would be undesirably expensive in
terms of memory or speed.

The default constructor puts `polymorphic_value` in an empty state where no
object is managed. Both `operator->` and `operator*` have preconditions where
calling them on an empty `polymorphic_value` is prohibited. An `explicit`
`operator bool` is provided to allow idiomatic checking for a null state.

[heading Reference stability]

`polymorphic_value` makes no guarantees of the stability of pointers and
references obtained from `operator->` and `operator*`. `polymorphic_value`
models a value-type like optional or variant and may make use of a small object
optimization to avoid heap allocation for small objects. Such an optimisation
would render pointers and references to a managed object invalid after a move
operation. The result of `operator->` and `operator*` should be used directly,
not cached for later use.

    // recommended use
    polymorphic_value<Shape> pv(Circle(8));
    foo(*pv);
    double area = pv->Area();

    // mis-use (pointer stability not guaranteed)
    polymorphic_value<Shape> pv(Circle(8));
    Shape* s = pv.operator->();
    foo(*pv);
    double area = s->Area();

The unnatural looking code that one is required to write to cache a pointer to
a `polymorphic_value`'s managed object should be a suitable deterrent.

[endsect]

[section When to use `polymorphic_value`]

`polymorphic_value` is designed to be used in polymorphic component-based
designs where the set of possible component types is open to extension
(open-set polymorphism).

`polymorphic_value` introduces a virtual function call into copy construction
and memory indirection into member function invocation. C++ advocates only
paying for what you use so we would advocate avoiding the unnecessary use of
`polymorphic_value`.

If a component design does not require polymorphic components then storing
components by value may be a better choice than using `polymorphic_value`.

If a component design does not require mutable components then storing
components by `std::shared_ptr<const T>` may be a better choice than using
`polymorphic_value` (Note the `const`).

If a component design has component sub-types chosen from a known set of
sub-types, then an `std::variant<A,B,C>` may be a better choice than using
`polymorphic_value`.

If a component design requires an open or extensible set of component sub-types,
and mutability of components then `polymorphic_value` may be a good choice.
[endsect]

[section Custom copiers and deleters]

`polymorphic_value` supports the use of custom copiers and deleters through a
raw-pointer constructor where the `polymorphic_value` takes ownership of the
pointer.

    template <class U, 
              class C=boost::default_copy<U>, 
              class D=default_delete<U>>
              // requires U* is convertible to T*
    polymorphic_value(U* u, C c = C{}, D d = D{});

This constructor is intended for situations where the copy constructor of `U`
and `delete U` are not appropriate choices. 

When objects are created from a C-API there may be API-provided methods to
create, copy and delete objects. The pointer-constructor of polymorphic_value
would enable use of such objects.

    // C-API pointer
    struct c_api_t;
    using c_api_p = c_api_t*;

    // C-API functions
    c_api_p c_api_object_create(int arg);
    c_api_p c_api_object_copy(c_api_p p);
    void c_api_object_dispose(c_api_p p);

    polymorphic_value<c_api_t> pv(
      c_api_object_create(42),
      [](const c_api_t& o) { return c_api_object_copy(&o);},
      [](const c_api_p* p) { c_api_object_dispose(p); }
    );

[heading Migrating from a `Clone` method]

The pointer constructor can be used to migrate from a class heirarchy with a
`Clone` method. 

Suppose there is a base class that inherits from the mixin `Cloneable`:

    template <class T>
    struct Cloneable {
      virtual ~Cloneable() = default;
      virtual std::unique_ptr<T> Clone() const = 0;
    };

    class Shape : public Cloneable<Shape>
    {
     public:
      virtual ~Shape() = default;
      // ... 
    };

We can use the pointer constructor to ensure that `polymorphic_value` calls the
clone method. 
    
    std::unique_ptr<Shape> s = shape_factory("Ellipse");
    polymorphic_value<Shape> pv(
      s.release(),
      [](const Shape& o) { return o.Clone().release(); },
    );

Once `Clone` is only used within `polymorphic_value` we can modify
`Shape` to make it copyable.

    class Shape : public Cloneable<Shape>
    {
     public:
      virtual ~Shape() = default;
      Shape(const Shape&) = default; 
      Shape(Shape&&) = default; 
      Shape& operator=(const Shape&) = default; 
      Shape& operator=(Shape&&) = default; 
      // ... 
    };
    
    std::unique_ptr<Shape> s = shape_factory("Ellipse");
    polymorphic_value<Shape> pv(s.release());

[endsect]

[endsect]
